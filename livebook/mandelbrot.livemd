<!-- livebook:{"file_entries":[{"name":"Screenshot-2024-11-14-at-19.22.38.jpeg","type":"attachment"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/Users/nevendrean/Desktop/Screenshot 2024-11-14 at 19.22.38.png"},"name":"Screenshot_2024-11-14_at_19.22.38.png","type":"file"}]} -->

# Mandelbrot set with Elixir Nx and Zigler

```elixir
Mix.install(
  [
    {:nx, "~> 0.9.1"},
    {:exla, "~> 0.9.1"},
    {:kino, "~> 0.14.2"},
    {:zigler, "~> 0.13.3"},
  ],
  config: [nx: [default_backend: EXLA.Backend]]
)

Nx.Defn.global_default_options(compiler: EXLA, client: :host)
```

## Warning

If you run into an error above, this means that you don't have Zig. Comment the package `Zigler` above.
This means you can't run the very last module where we use inline `Zig` code.

```elixir
# :observer.start()
```

### Table of contents

1. [Introduction](#introduction)
2. [Play with orbits](#play-with-orbits)
3. [Complex calculus](#complex-calculus)
4. [Algorithm](#algorithm)
5. [Orbit and iteration number](#orbit-and-iteration-number)
6. [Some colour palettes](#some-colour-palettes)
7. [Computing Mandelbrot set](#computing-the-mandelbrot-set)
8. [Parallelise it](#parallelise-it)
9. [Zoom in and out](zoom-in-and-out)
10. [Speed up with Zig embedded code](#speed-up-with-zig-embedded-code)
11. [Zoom-in-with-Zig](#zoom-in-with-zig)

## Introduction

We want to produce an image that represents the beautiful **Mandelbrot set**. With one module below, you can zoom into the fractal.

Source: <https://en.wikipedia.org/wiki/Mandelbrot_set>

<https://www.math.univ-toulouse.fr/~cheritat/wiki-draw/index.php/Mandelbrot_set>

We use the `Nx` library with the `EXLA` backend to speed up the computations.

We also propose to run the equivalent code in `Zig` in this `Livebook` if you want extra speed. This happens thanks to the [Zigler](https://hexdocs.pm/zigler/Zig.html) library. The `Zig` code returns a binary that `Nx` is able to consume and `Kino` to display.

### What is a Mandelbrot set?

In a "Mandlebrot image", each pixel has a colour repesenting how _fast_ the _underlying point_ _"escapes"_ when calculating its _iterates_ under a certain function.

### What is an underlying point?

A pixel has some coordinates `[i,j]`. For example, in a 1024 × 768 image (WIDTH x HEIGHT), the row number varies from from 0 to 1023 and column number from 0 to 767.

We transform these couples of integers `(i,j)` into a point into a 2D plane. This map "quantitizes" the 2D plane.

Here, the 2D "real" plan is defined by the upper left corner, say `(-2,1)`, and bottom right corner, say `(1,-1)`.

**How?** We have a linear mapping between the couple `(i,j)` and a point `(x,y)` in the defined zone. For example, the pixel `(0,0)` becomes `(-2,1)` and the pixel `(767, 1023)` becomes `(1,-1)`.

### What is iterating?

We will iterate the function: `x -› x*x +c` where `c` is a given number and `x` the variable.

We start with:

```
z0 = f(0) = c
z1 = f(z0) = z0 * z0 + c
z2 = f(z1) = z1 * z1 + c
...
```

Let's take an example. The module below calculates the iterations `x(n) = f(x(n-1))` by a simple recursion.

The sets of these iterates of `c` is called its _orbit_ .

```elixir
defmodule Simple do
  def p(x,c), do: x**2 + c

  def iterate(0,c), do: c
  def iterate(n,c), do: p(iterate(n-1, c), c)
end
```

We calculate the first elements of its orbit and evaluate how does the point `c=1` behaves. It looks like it will diverge to infinity.

```elixir
c = 1
{ c,
  Simple.iterate(1,c), Simple.iterate(2,c), Simple.iterate(3,c), Simple.iterate(4,c), Simple.iterate(5,c), Simple.iterate(6,c),
}
```

gives:

```
{1, 1, 2, 5, 26, 677, 458330}
```

On the other side, the point `c=-1` seems well bahaved: the orbit has only two values, 0 and - 1, and is periodic.

```elixir
c = -1

{ c,
  Simple.iterate(1,c), Simple.iterate(2,c), Simple.iterate(3,c), Simple.iterate(4,c),Simple.iterate(5,c),Simple.iterate(6,c),
}
```

gives:

```
{-1, -1, 0, -1, 0, -1, 0}
```

In the examples above, we took a simple "real" number.

For the Mandelbrot set, we use the complex representation of a point: `(x,y) -> x + y*i` where `i` is the imaginary number, `Nx.Constants.i`.

So, each pixel `(i,j)` is mapped to a complex number `c = projection(i,j)`, and we want to evaluate how do the iterates of `c` behave under this iteration starting at `z0 = 0`.

<!-- livebook:{"break_markdown":true} -->

### Iteration number?

We are interested by assigning an **iteration number** to each `c`.

The number of iterations needs to be bounded (think of a periodic orbit). Let `max_iter` be the maximum number of iterations, for example 100.

If the orbit of `c` remains bounded, we assign an _iteration number_ to `max_iter`.

If it escapes, meaning one iterate has a norm greater than 2, then we calculate the _first index_ such that the iterate norm is greater than 2 (in absolute value as a complex, or its norm as a point).

If we inspect the orbits, we discover ncie figures. The Livebook below lets you play with the plan and displays orbits on-click.

## Play with orbits

Livebook to compute orbits:

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2Fndrean%2Fmandelbrot%2Fblob%2Fmain%2Flivebook%2Forbits.livemd)

<!-- livebook:{"break_markdown":true} -->

![](files/Screenshot-2024-11-14-at-19.22.38.jpeg)

## Complex calculus

We will use two types of functions:

* `Elixir` functions using `def`
* `Nx` functions using `defn`; these use a special backend (EXLA with CPU or GPU if any). Within a numerical function, all the arguments are treated as _tensors_. To pass a non-tensor argment, use an `opts` keyword.

The points of the 2D plane will be represented as complex numbers as the Mandelbrot map works with complex numbers.

The function `z(n+1) = z(n) * z(n) + c` takes a complex number and returns a complex number.

## Algorithm

Source: <https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set>

**Input**: image dimensions (eg w x h of 1500 x 1000), max iteration (eg 100)

Iterate over each pixel `(i,j)`:

* map it into the 2D plane: compute its "complex coordinates"
* compute the iteration number
* compute a colour
* Sum-up and draw from the final tensor with `Kino`.

An example of a zoom into an area. You can go as deep as you want with these fractals objects.

![Detail mandlebrot](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/yajf9ojv7h927nx8u3qi.png)

### Pixel to complex plan mapping

This module transforms a couple `(i,j)` into a complex number. It is a numerical function.

> a tensor can be of type complex `c64`. A numerical `Nx` function natively understands complex numbers. Note that we use the built-in constant `i()`.

```elixir
defmodule Pixel do
  import Nx.Defn
  import Nx.Constants, only: [i: 0]

  defn map(index, {h,w}, {top_left_x, top_left_y, bottom_right_x,bottom_right_y}) do

    scale_x = (bottom_right_x-top_left_x) / (w-1)
    scale_y = (bottom_right_y-top_left_y) / (h-1)

    # building a complex typed tensor
    top_left_x + index[1] * scale_x + i() * (top_left_y + index[0] * scale_y)
  end
end
```

## Orbit and iteration number

This module computes the **iteration number** for a given input `c`. It is a numerical function.

How does this work?

* If `|c|>2`, then this point is unstable. Otherwise, we have to compute for each point whether it stays bounded or not.

* If it is bounded, we get `max_iter`, otherwise a lower value.

We cannot use the recursion form we did earlier because numerical functions don't accept several headers as plain Elixir.
Instead we use the `"Nx"-while` loop. Note how we use the `Nx` versions of `cond`. In this context, `true` is the tensor `1`.

```elixir
defmodule Orbit do
  import Nx.Defn

  defn poly(z,c), do: z*z + c

  # for speed, we don't use the norm (square root involved), only the square of the norm
  defn sq_norm(z), do: Nx.real(Nx.conjugate(z) * z)

  defn number(c,opts) do
    max_iter = opts[:imax]
    condition = (Nx.real(c) +1) ** 2 + (Nx.imag(c)**2)
    cond do
      # points in first cardioid are all stable. Save on iterations
      Nx.less(condition, 0.0625) ->
        max_iter
      # these points are unbounded whenever the norm is > 2
      Nx.greater(sq_norm(c), 4) ->
        0
      # evaluate each point as it can be bounded or not in the disk 2
      1 ->
          {i, _, _} =
            while {i=max_iter, z=c, c}, Nx.greater(i,1) and Nx.less(sq_norm(z), 4) do
                {i-1, poly(z,c), c}
            end
          max_iter - i + 1
      end
    end
end

```

## Some colour palettes

Each **iteration number** is an integer `n`. We want to associate a colour [r(n),g(n),b(n)].

This will help us to visualise which point of the complex plane is stable, and if not how fast it escapes.

The choice below is just an example. The first render uses the `rbg` function whilst the second the `rgb2`. Other choices can be made.

```elixir
defmodule Colour do
  import Nx.Defn

  defn rgb(n, max_iter) do
    n = n / max_iter
    cond do
      Nx.equal(n, 0) ->
        Nx.stack([255, 255, 0])
      Nx.less(n, 0.5) ->
        s = n * 2
        r = 255 * (1 - s)
        g = 255 * (1 - s/2)
        b = 127 + 128 * s
        Nx.stack([r, g, b])
      true ->
        s = 2 * n - 1
        r = 0
        g = 127 * (1 - s)
        b = 255 * (1 - s)
         Nx.stack([r, g, b])
    end
  end

  defn rgb2(n, max_iter) do
    v = Nx.remainder(n,16)
    cond do
      Nx.equal(n, max_iter) -> Nx.stack([0,0,0])
      Nx.equal(v,0) -> Nx.stack([66, 30, 15]) 
      Nx.equal(v,1) -> Nx.stack([25, 7, 26]) 
      Nx.equal(v,2) -> Nx.stack([9, 1, 47])
      Nx.equal(v,3) -> Nx.stack([4, 4, 73]) 
      Nx.equal(v,4) -> Nx.stack([0, 7, 100]) 
      Nx.equal(v,5) -> Nx.stack([12, 44, 138]) 
      Nx.equal(v,6) -> Nx.stack([24, 82, 177]) 
      Nx.equal(v,7) -> Nx.stack([57, 125, 209]) 
      Nx.equal(v,8) -> Nx.stack([134, 181, 229]) 
      Nx.equal(v,9) -> Nx.stack([211, 236, 248]) 
      Nx.equal(v,10) -> Nx.stack([241, 233, 191]) 
      Nx.equal(v,11) -> Nx.stack([248, 201, 95]) 
      Nx.equal(v,12) -> Nx.stack([255, 170, 0]) 
      Nx.equal(v,13) -> Nx.stack([204, 128, 0]) 
      Nx.equal(v,14) -> Nx.stack([153, 87, 0]) 
      Nx.equal(v,15) -> Nx.stack([106, 52, 3]) 
      1 -> Nx.stack([0,0,0])
    end
  end
end
```

## Computing the Mandelbrot set

**The final module**

We reassemble the tensor into the desired format for `Kino` to consume it and display.

> Note that you want to pass arguments into a `defn` function that you don't want to be treated as tensors, you need to use a keyword list or a map.

```elixir
defmodule Mandelbrot do
  import Nx.Defn

  defn compute(opts) do
    top_left_x = -2; top_left_y = 1.2; bottom_right_x = 0.6; bottom_right_y = - 1.2;
    defining_points = {top_left_x, top_left_y, bottom_right_x, bottom_right_y}

    h = opts[:h]
    w = opts[:w]
    max_iter = opts[:max_iter]

    # build the tensor [[0,0],, ...[0,m], [1,1]...[n,m]]. Thks to PValente
    iota_rows = Nx.iota({h}, type: :u16) |> Nx.vectorize(:rows)
    iota_cols = Nx.iota({w}, type: :u16) |> Nx.vectorize(:cols)
    cross_product = Nx.stack([iota_rows, iota_cols])

    Pixel.map(cross_product,{h,w}, defining_points)
      |> Orbit.number(imax: max_iter)
      |> Colour.rgb(max_iter)
      |> Nx.devectorize()
      |> Nx.reshape({h, w, 3})
      |> Nx.as_type(:u8)
  end
end

```

Depending on your machine, the computation below can be lengthy.
If you want to simply evaluate, set low values `h = w = 300` and `max_iter = 100`.

```elixir
h = 400; w = 500
Mandelbrot.compute(h: h, w: w, max_iter: 100)
|> Kino.Image.new()
```

## Parallelise it

When the resolution of the image increases, it is interesting to parallelise the computations.

We divide the image in horizontal bands by fixing the numbers of rows. Then we spawn as many tasks as needed.

> This is worth only if the size of the image is large enough as this comes with non negligible overhead.

Lastly, another possible optimisation is to remark that the image is symmetric when you compute the full image. You can compute half of the image and stack to it the reversed tensor. This gives an extra boost.

This is done in `StreamMandelbrot.parall_sym`

```elixir
defmodule StreamMandelbrot do
  import Nx.Defn


  # bottom_right_y = 0 <--- we computate only plane y>0
  defn compute_half(cross_product, %{h: h, w: w, max_iter: max_iter}) do
    top_left_x = -2; top_left_y = 1.2; bottom_right_x = 0.6; bottom_right_y = 0;
    defining_points = {top_left_x, top_left_y, bottom_right_x, bottom_right_y}

    Pixel.map(cross_product,{h,w}, defining_points)
    |> Orbit.number(imax: max_iter)
    |> Colour.rgb2(max_iter)
    |> Nx.devectorize()
    |> Nx.as_type(:u8)
  end

  #--------------------------------------------------------------------------------
  # Fix the number of rows and spawn concurrently and compute half (for full image)
  #--------------------------------------------------------------------------------

  def paral_sym(%{h: h, w: w} = opts) do
    half_h = div(h,2)
    
    rows_per_task = 30
    half_new = half_h - rem(half_h, rows_per_task)
    nb_tasks = div(half_new, rows_per_task) 
    opts = Map.merge(opts, %{h: half_new })
    {half_new, nb_tasks, rows_per_task, h} |> dbg()

      tasks_half_tensor =
        for task_id <- 0.. nb_tasks-1 do
          Task.async(fn -> 
            iota_rows =
              Nx.iota({rows_per_task}, type: :u16)
              |> Nx.add(task_id * rows_per_task)
              |> Nx.vectorize(:rows)
            # full width
            iota_cols =
              Nx.iota({w}, type: :u16)
              |> Nx.vectorize(:cols)
            cross_product = Nx.stack([iota_rows, iota_cols])
            
            Nx.Defn.jit_apply(fn t ->
              computed_rows = compute_half(t, opts) 
              {task_id, computed_rows}
              end, 
              [cross_product]
            )
          end)
        end

      half_tensor =   
        Task.await_many(tasks_half_tensor, :infinity)
        |> Enum.sort(fn {x,_}, {y,_} -> Nx.to_number(x)<= Nx.to_number(y) end)
        |> Enum.map(&(elem(&1, 1)))
        |> Nx.stack()
        |> Nx.devectorize()
          

      flah_tensor =
        Nx.tensor(half_tensor, names: [:cpus, :rows, :cols, :rgbs])
        |> Nx.reverse(axes: [:cpus, :rows])

      Nx.stack([half_tensor, flah_tensor]) |> Nx.reshape({half_new * 2, w, 3})
  end
  
end
```

We get the expected performance boost. We are able to incrase the resolution.

> For the fun, we changed the colour palette.

```elixir
h = 800; w = 1000

StreamMandelbrot.paral_sym( %{h: h, w: w, max_iter: 150})
|> Kino.Image.new()
```

## Zoom in and out

In this module, we are able to click on a point of the image and zoom in and dive into the fractal.

We pass __binary__ between the browser and the Livebook used as a server. This happens thanks to `Kino.JS.Live` who supports using binary data.

Given some bounds of the 2D-plan within our canvas, we will pass "quantitized" coordinates of the 2D-plan. To each `(i,j)` of the canvas, we compute in the browser the "real" coordinates `(x,y)` and pass this as a binary to the Livebook. For example, when you have 600 x 800 points as floats (4 bytes per float for f32), we pass 600x800x2x4 = 3_840_000 = 3.8MB of data.

> send the binary within an `ArrayBuffer` container, and allocate an `Float32Array` view.

With `Nx.from_binary(binary, :f32)`, we can enter the `Nx` world. We parallelise the computations by running `Task.async` whe we chunk the rows, and reassemble the resulting tensors by the _task_id_ .

We then send back to the browser the resulting tensor with `Nx.to_binary`, the size becomes 600x800x3 = 1.44MB. This is because we are sending now `u8` integers representing the R,G,B of each point.

We don't want to use data as strings  (data:image base 64) as this increases the weight and thus slows down the rendering.

We can transform the binary into RGBA and display it into the canvas by building an `ImageData`.

> use the `Uint8Array` container and allocate an `Uint8ClampedArray` view. Then use the `ImageData` from the Canvas API and `window.createImageBitmap` to fill in the canvas.

```elixir
defmodule Zoom do
  import Nx.Defn

  @h 400 #800
  @w  500 #1100
  @imax 150
  @rows_per_task 20

  # Nx computations ------------------------------------
  defn compute(slice, %{max_iter: max_iter}) do
    Orbit.number(slice, imax: max_iter)
    |> Colour.rgb2(max_iter)
    |> Nx.devectorize()
    |> Nx.as_type(:u8)
  end

  defn to_complex(t), do: Nx.complex(t[0], t[1])
  # <--------------------------------------------------
  
  def consume(binary, %{h: h, w: w, max_iter: max_iter}) do
    rows_per_task =  @rows_per_task
    tmp_rem = rem(h, rows_per_task) 
    rem = if tmp_rem == 0, do: rows_per_task, else: tmp_rem
    nb_tasks = div(h, rows_per_task)
    
    opts =  %{max_iter: max_iter}

    t = 
      Nx.from_binary(binary, :f32) 
      |> Nx.reshape({h, w, 2})
      # we want to "complexify" the points thus we need to vectorize both dimensions
      |> Nx.vectorize([:r, :c])
      |> to_complex()
      |> Nx.devectorize()

    
    computations = 
      for task_id <- 0..nb_tasks do
        Task.async(fn ->
          # we shift the start index by the number of rows already consummed
          start_row = task_id * rows_per_task
          remaining_tasks = 
            if task_id ==  (nb_tasks), do: min(rem, rows_per_task), else: rows_per_task
          
          slice = 
            Nx.slice(t, [start_row, 0], [remaining_tasks, w]) |> Nx.vectorize([:row, :col])
            
          # apply our Nx pipeline to the slice
          Nx.Defn.jit_apply(fn t ->
            computed_rows = compute(t, opts) 
            {task_id, computed_rows}
            end, 
            [slice]
          )
          end)
      end
      
    Task.await_many(computations, :infinity)
    # re-order as per the task_id we retunrned
    |> Enum.sort(fn {x,_}, {y,_} -> Nx.to_number(x)<= Nx.to_number(y) end)
    |> Enum.map(&(elem(&1, 1)))
    |> Nx.stack()
    |> Nx.devectorize()
    # send to the browser as binary
    |> Nx.to_binary()
  end


  # Kino.JS.Live ------------------------------------------------------
  use Kino.JS
  use Kino.JS.Live

  def canvas(h, w) do
    """
    <canvas id="myCanvas" width=#{w} height=#{h}></canvas>
    """
  end

  def start(), do: Kino.JS.Live.new(__MODULE__, canvas(@h, @w))

  @impl true
  def init(html, ctx) do
    ctx = assign(ctx, %{max_iter: @imax, h: @h, w: @w})
    {:ok, assign(ctx, html: html)}
  end

  @impl true
  def handle_connect(ctx) do
    {:ok, ctx.assigns.html, ctx}
  end

  @impl true
  def handle_event("clicked", {:binary,_, buffer}, %{assigns: assigns} = ctx) do
    %{h: h, w: w, max_iter: max_iter} = assigns
    binary = consume(buffer, %{h: h, w: w, max_iter: max_iter})
    broadcast_event(ctx,"new", {:binary, %{}, binary})
    {:noreply, ctx}
  end

  
  asset "main.js" do
    """
    export function init(ctx, html) {
      ctx.root.innerHTML = html;

      const canvas = document.getElementById("myCanvas");
      const canvasCtx = canvas.getContext("2d");
      const canvasWidth = canvas.width, canvasHeight = canvas.height;
    
      // initial bounds
      let boundary = {min_x: -2, max_y: 1, max_x: 1, min_y: -1};

      // Function to convert canvas coordinate to complex coordinate
      function toCartesian(canvasX, canvasY, bounds) {
        const {min_x, max_x, min_y, max_y} = bounds;
        const x = min_x + (canvasX / (canvasWidth-1)) * (max_x - min_x);
        const y = max_y - (canvasY / (canvasHeight-1)) * (max_y - min_y);
        return { x, y };
      }

      function recalculateBounds(canvasX, canvasY, bounds, options = {}) {
        // Get the clicked point's corresponding 2D plane coordinates
        const { x: newCenterX, y: newCenterY } = toCartesian(canvasX, canvasY, bounds)
        const { zoomRatio = 5, zoomIn = true} = options;

        const {min_x, max_x, min_y, max_y} = bounds;
        // Compute the width and height of the new zoomed rectangle
        const oldWidth = max_x - min_x;
        const oldHeight = max_y - min_y;

        const factor = zoomIn ? 1/zoomRatio : zoomRatio;
        const newWidth = oldWidth * factor;
        const newHeight = oldHeight * factor;
      
        return { 
          min_x: newCenterX - newWidth / 2,
          max_x: newCenterX + newWidth / 2, 
          min_y: newCenterY - newHeight / 2, 
          max_y: newCenterY + newHeight / 2
        };
      }
    
      // received from server -----------------------------------
      ctx.handleEvent("new", ([_, binary]) => {
        console.log("new")
        const rgbArray = new Uint8Array(binary);
        const imageDataArray = new Uint8ClampedArray(
          canvasWidth * canvasHeight * 4
        ); // RGBA
        
        // Fill the Uint8ClampedArray with RGB data, add alpha channel
        for (let i = 0, j = 0; i < rgbArray.length; i += 3, j += 4) {
          imageDataArray[j] = rgbArray[i];     // R
          imageDataArray[j + 1] = rgbArray[i + 1]; // G
          imageDataArray[j + 2] = rgbArray[i + 2]; // B
          imageDataArray[j + 3] = 255;         // Alpha (fully opaque)
        }

        // Create ImageData object
        const imageData = new ImageData(imageDataArray, canvasWidth, canvasHeight);
      
        // Render the image onto the canvas
        createImageBitmap(imageData).then(bitmap => canvasCtx.drawImage(bitmap, 0, 0))
          
      });

      // push from browser -------------------------------------
      canvas.addEventListener("click", (e) => {
        //if (!e.ctrlKey) return; // <-- click + ctrl pressed to zoom it
        const rect = canvas.getBoundingClientRect();
        const canvasX = e.clientX - rect.left;
        const canvasY = e.clientY - rect.top;
        const newBounds = recalculateBounds(canvasX, canvasY, boundary, {zoomIn: !e.shiftKey});
    
        //-- send data to the server -->
        Object.assign(boundary, newBounds);
        const buffer = getPoints(boundary)
        ctx.pushEvent("clicked", [{}, buffer])
      });

      


      // compute all cartesians coordinntes in the current canvas
      function getPoints(bounds) {
        const buffer = new ArrayBuffer(canvasWidth * canvasHeight * 2 * 4); // 2 floats per pixel, 4 bytes each
        const floatArray = new Float32Array(buffer);

        let index = 0;
        for (let n = 0; n < canvasWidth * canvasHeight; n++) {
          const { x, y } = toCartesian(
              n % canvasWidth,              // i
              Math.floor(n / canvasWidth),  // j
              bounds
          );
          floatArray[n * 2] = x;
          floatArray[n * 2 + 1] = y;
        }
        return buffer;
      }

      // first render---------------
      const buffer = getPoints(boundary)
      ctx.pushEvent("clicked", [{}, buffer])
    }
    """
  end
end
```

You can `CTRL+CLICK` to zoom into the point of your choice. The zoom factor is 10.

You can dezoom with `CTRL+SHIFT+CLICK`.

```elixir
Zoom.start()
```

## Speed up with Zig embedded code

If we still need or want extra speed, we can also embed `Zig` code in `Elixir` within a Livebook.

`Zigler` offers a [remarkable documentation](https://hexdocs.pm/zigler/readme.html#installation-elixir).

:exclamation: You may to have `Zig` installed on your machine.

In the `Livebook`, we add the dependencies (in the first cell):

<!-- livebook:{"force_markdown":true} -->

```elixir
Mix.install([{:zigler, "~> 0.13.3"},{:zig_get, "~> 0.13.1"},])
```

With the `Zigler`, we can even inline Zig code.

The code below runs the same algorithm and runs __OS threads__ (bands of rows) for concurrency.

> we use the `beam` memory allocator from the library.

> the slice is returned as a binary - typed as `beam.term` - to be easily consumed by `Nx` and then `Kino`.

```elixir
defmodule Zigit do
  use Zig, otp_app: :zigler,
    nifs: [..., generate_mandelbrot: [:threaded]],
    release_mode: :fast

  ~Z"""
    const beam = @import("beam");
    const std = @import("std");
    const Cx = std.math.Complex(f64);

    const topLeft = Cx{ .re = -2.1, .im = 1.2 };
    const bottomRight = Cx{ .re = 0.6, .im = -1.2 };
    const w = bottomRight.re - topLeft.re;
    const h = bottomRight.im - topLeft.im;

    const Context = struct {res_x: usize, res_y: usize, imax: usize};

    /// nif: generate_mandelbrot/3 Threaded
    pub fn generate_mandelbrot(res_x: usize, res_y: usize, max_iter: usize) !beam.term {
        const pixels = try beam.allocator.alloc(u8, res_x * res_y * 3);
        defer beam.allocator.free(pixels);

        const resolution = Context{ .res_x = res_x, .res_y = res_y, .imax = max_iter };

        const res = try createBands(pixels, resolution);
        return beam.make(res, .{ .as = .binary });
    }

    // <--- threaded version
    fn createBands(pixels: []u8, ctx: Context) ![]u8 {
        const cpus = try std.Thread.getCpuCount();
        var threads = try beam.allocator.alloc(std.Thread, cpus);
        defer beam.allocator.free(threads);

        // half of the total rows
        const rows_to_process = ctx.res_y / 2 + ctx.res_y % 2;
        // one band is one count of cpus
        // const nb_rows_per_band = rows_to_process / cpus + rows_to_process % cpus;
        const rows_per_band = (rows_to_process + cpus - 1) / cpus;

        for (0..cpus) |cpu_count| {
            const start_row = cpu_count * rows_per_band;

            // Stop if there are no rows to process
            if (start_row >= rows_to_process) break;

            const end_row = @min(start_row + rows_per_band, rows_to_process);
            const args = .{ ctx, pixels, start_row, end_row };
            threads[cpu_count] = try std.Thread.spawn(.{}, processRows, args);
        }
        for (threads[0..cpus]) |thread| {
            thread.join();
        }

        return pixels;
    }

    fn processRows(ctx: Context, pixels: []u8, start_row: usize, end_row: usize) void {
        for (start_row..end_row) |current_row| {
            processRow(ctx, pixels, current_row);
        }
    }

    fn processRow(ctx: Context, pixels: []u8, row_id: usize) void {
        // Calculate the symmetric row
        const sym_row_id = ctx.res_y - 1 - row_id;

        if (row_id <= sym_row_id) {
            // loop over columns
            for (0..ctx.res_x) |col_id| {
                const c = mapPixel(.{ @as(usize, @intCast(row_id)), @as(usize, @intCast(col_id)) }, ctx);
                const iter = iterationNumber(c, ctx.imax);
                const colour = createRgb(iter, ctx.imax);

                const p_idx = (row_id * ctx.res_x + col_id) * 3;
                pixels[p_idx + 0] = colour[0];
                pixels[p_idx + 1] = colour[1];
                pixels[p_idx + 2] = colour[2];

                // Process the symmetric row (if it's different from current row)
                if (row_id != sym_row_id) {
                    const sym_p_idx = (sym_row_id * ctx.res_x + col_id) * 3;
                    pixels[sym_p_idx + 0] = colour[0];
                    pixels[sym_p_idx + 1] = colour[1];
                    pixels[sym_p_idx + 2] = colour[2];
                }
            }
        }
    }

    fn mapPixel(pixel: [2]usize, ctx: Context) Cx {
        const px_width = ctx.res_x - 1;
        const px_height = ctx.res_y - 1;
        const scale_x = w / @as(f64, @floatFromInt(px_width));
        const scale_y = h / @as(f64, @floatFromInt(px_height));

        const re = topLeft.re + scale_x * @as(f64, @floatFromInt(pixel[1]));
        const im = topLeft.im + scale_y * @as(f64, @floatFromInt(pixel[0]));
        return Cx{ .re = re, .im = im };
    }

    fn iterationNumber(c: Cx, imax: usize) ?usize {
        if (c.re > 0.6 or c.re < -2.1) return 0;
        if (c.im > 1.2 or c.im < -1.2) return 0;

        // first cardiod
        if ((c.re + 1) * (c.re + 1) + c.im * c.im < 0.0625) return null;

        var z = Cx{ .re = 0.0, .im = 0.0 };
        for (0..imax) |j| {
            if (sqnorm(z) > 4) return j;
            z = Cx.mul(z, z).add(c);
        }
        return null;
    }

    fn sqnorm(z: Cx) f64 {
        return z.re * z.re + z.im * z.im;
    }

    fn createRgb(iter: ?usize, imax: usize) [3]u8 {
        // If it didn't escape, return black
        if (iter == null) return [_]u8{ 0, 0, 0 };

        // Normalize time to [0,1[ now that we know it isn't "null"
        const normalized = @as(f64, @floatFromInt(iter.?)) / @as(f64, @floatFromInt(imax));

        if (normalized < 0.5) {
            const scaled = normalized * 2;
            return [_]u8{ @as(u8, @intFromFloat(255 * (1 - scaled))), @as(u8, @intFromFloat(255.0 * (1 - scaled / 2))), @as(u8, @intFromFloat(127 + 128 * scaled)) };
        } else {
            const scaled = (normalized - 0.5) * 2.0;
            return [_]u8{ 0, @as(u8, @intFromFloat(127 * (1 - scaled / 2))), @as(u8, @intFromFloat(255 * (1 - scaled))) };
        }
    }


  """
end
```

We run the Zig code. It returns a binary that we are able to consume with `Nx` and display the image.

To draw an image of 1M pixels, it takes a few milliseconds. Feels like magic.

```elixir
h = 1000; w = 1200
max_iter = 200;

Zigit.generate_mandelbrot(w, h, max_iter)
|> Nx.from_binary(:u8)
|> Nx.reshape({h, w, 3})
|> Kino.Image.new()
```

## Misiurewicz point

```elixir
defmodule Mand do
  use Zig, otp_app: :zigler,
    nifs: [..., generate_misiurewicz: [:threaded]],
    release_mode: :fast


  ~Z"""
    const beam = @import("beam");
    const std = @import("std");
    const Cx = std.math.Complex(f64);

    const print = std.debug.print;

    const Context = struct { res_x: usize, res_y: usize, imax: usize, w: f64, h: f64, topLeft: Cx, bottomRight: Cx };

    /// nif: generate_misiurewicz/7 Threaded
    pub fn generate_misiurewicz(res_x: usize, res_y: usize, imax: usize, topLeft_x: f64, topLeft_y: f64, bottomRight_x: f64, bottomRight_y: f64) !beam.term {
        const pixels = try beam.allocator.alloc(u8, res_x * res_y * 3);
        defer beam.allocator.free(pixels);

        const tl = Cx{ .re = topLeft_x, .im = topLeft_y };
        const br = Cx{ .re = bottomRight_x, .im = bottomRight_y };
        const w = br.re - tl.re;
        const h = br.im - tl.im;
        // threaded version
        const ctx = Context{ .res_x = res_x, .res_y = res_y, .imax = imax, .topLeft = tl, .bottomRight = br, .w = w, .h = h };
        const res = try createBands(pixels, ctx);
        return beam.make(res, .{ .as = .binary });
    }

    // <--- threaded version
    fn createBands(pixels: []u8, ctx: Context) ![]u8 {
        const cpus = try std.Thread.getCpuCount();
        var threads = try beam.allocator.alloc(std.Thread, cpus);
        defer beam.allocator.free(threads);

        const rows_to_process = ctx.res_y;
        // one band is one count of cpus
        const rows_per_band = (rows_to_process + cpus - 1) / cpus;

        for (0..cpus) |cpu_count| {
            const start_row = cpu_count * rows_per_band;

            // Stop if there are no rows to process
            if (start_row >= rows_to_process) break;

            const end_row = @min(start_row + rows_per_band, rows_to_process);
            const args = .{ ctx, pixels, start_row, end_row };
            threads[cpu_count] = try std.Thread.spawn(.{}, processRows, args);
        }
        for (threads[0..cpus]) |thread| {
            thread.join();
        }

        return pixels;
    }

    fn processRows(ctx: Context, pixels: []u8, start_row: usize, end_row: usize) void {
        for (start_row..end_row) |current_row| {
            processRow(ctx, pixels, current_row);
        }
    }

    fn processRow(ctx: Context, pixels: []u8, row_id: usize) void {
        // loop over columns
        for (0..ctx.res_x) |col_id| {
            const c = mapPixel(.{ @as(usize, @intCast(row_id)), @as(usize, @intCast(col_id)) }, ctx);
            const iter = iterationNumber(c, ctx.imax);
            const colour = createRgb2(iter, ctx.imax);

            const p_idx = (row_id * ctx.res_x + col_id) * 3;
            pixels[p_idx + 0] = colour[0];
            pixels[p_idx + 1] = colour[1];
            pixels[p_idx + 2] = colour[2];
        }
    }

    fn mapPixel(pixel: [2]usize, ctx: Context) Cx {
        const px_width = ctx.res_x - 1;
        const px_height = ctx.res_y - 1;
        const scale_x = ctx.w / @as(f64, @floatFromInt(px_width));
        const scale_y = ctx.h / @as(f64, @floatFromInt(px_height));

        const re = ctx.topLeft.re + scale_x * @as(f64, @floatFromInt(pixel[1]));
        const im = ctx.topLeft.im + scale_y * @as(f64, @floatFromInt(pixel[0]));
        return Cx{ .re = re, .im = im };
    }

    fn iterationNumber(c: Cx, imax: usize) ?usize {
        if (c.re > 0.6 or c.re < -2.1) return null;
        if (c.im > 1.2 or c.im < -1.2) return null;
        // first cardiod
        if ((c.re + 1) * (c.re + 1) + c.im * c.im < 0.0625) return null;

        var x2: f64 = 0;
        var y2: f64 = 0;
        var w: f64 = 0;

        for (0..imax) |j| {
            if (x2 + y2 > 4) return j;
            const x: f64 = x2 - y2 + c.re;
            const y: f64 = w - x2 - y2 + c.im;
            x2 = x * x;
            y2 = y * y;
            w = (x + y) * (x + y);
        }

        // var z = Cx{ .re = 0.0, .im = 0.0 };
        // for (0..imax) |j| {
        //     if (sqnorm(z) > 4) return j;
        //     z = Cx.mul(z, z).add(c);
        // }
        return null;
    }

    fn sqnorm(z: Cx) f64 {
        return z.re * z.re + z.im * z.im;
    }


    fn createRgb2(iter: ?usize, imax: usize) [3]u8 {
        // If it didn't escape, return black
        if (iter == null) return [_]u8{ 0, 0, 0 };

        if (iter.? < imax and iter.? > 0) {
            const i = iter.? % 16;
            return switch (i) {
                0 => [_]u8{ 66, 30, 15 },
                1 => [_]u8{ 25, 7, 26 },
                2 => [_]u8{ 9, 1, 47 },
                3 => [_]u8{ 4, 4, 73 },
                4 => [_]u8{ 0, 7, 100 },
                5 => [_]u8{ 12, 44, 138 },
                6 => [_]u8{ 24, 82, 177 },
                7 => [_]u8{ 57, 125, 209 },
                8 => [_]u8{ 134, 181, 229 },
                9 => [_]u8{ 211, 236, 248 },
                10 => [_]u8{ 241, 233, 191 },
                11 => [_]u8{ 248, 201, 95 },
                12 => [_]u8{ 255, 170, 0 },
                13 => [_]u8{ 204, 128, 0 },
                14 => [_]u8{ 153, 87, 0 },
                15 => [_]u8{ 106, 52, 3 },
                else => [_]u8{ 0, 0, 0 },
            };
        }
        return [_]u8{ 0, 0, 0 };
      }
  """
end
```

```elixir
x0 = -0.1011
y0 = 0.9563
tl_x = x0 - 0.0001
tl_y = y0 + 0.0001
br_x = x0 + 0.0001
br_y = y0 - 0.0001
h = 4_000
w = 5_000
max_iter = 400

Mand.generate_misiurewicz(w, h, max_iter, tl_x, tl_y, br_x, br_y)
|> Nx.from_binary(:u8)
|> Nx.reshape({h, w, 3})
|> Kino.Image.new()
```

## Zoom in with Zig

You can `CLICK` into the image and explore with the power of Zig.

```elixir
defmodule ZigSpeed do
  use Zig, otp_app: :zigler,
    #nifs: [..., generate_view],
    release_mode: :fast


  ~Z"""
  const beam = @import("beam");
  const std = @import("std");
    
  const print = std.debug.print;
    
  const Point = struct { x: f32, y: f32 };
  const point_size: usize = @sizeOf(Point);

  const Progress = struct {
    points_processed: usize,
    total_points: usize,
    elapsed_ms: u64,
  };
  
    
  // / nif: generate_view
  pub fn generate_view(data: [*]const u8, len: u32, imax: usize) !beam.term {
    if (len < @sizeOf(Point)) {
      return error.BufferTooSmall;
    }

    // Ensure the length is a multiple of point size
    if (len % @sizeOf(Point) != 0) {
        return error.InvalidBufferLength;
    }
    const start_time = std.time.milliTimestamp();
  
    // pointer the BEAM memory
    const raw_buffer = data[0..len];

    // Calculate how many points we expect
    const nb_points: usize = len / (@sizeOf(f32) * 2);

    // Create a slice of f32 values (two per point)
    const float_slice = std.mem.bytesAsSlice(f32, raw_buffer);

    const colours = try beam.allocator.alloc(u8, nb_points * 4);
    defer beam.allocator.free(colours);

    var i: usize = 0;
    var color_idx: usize = 0;
    while (i < float_slice.len) : (i += 2) {
      if (i + 1 >= float_slice.len) break;
      
      const point = Point{
          .x = float_slice[i],
          .y = float_slice[i + 1],
      };
  
      if (i % (float_slice.len / 10) == 0) {
        const progress = Progress{
            .points_processed = i / 2,
            .total_points = nb_points,
            .elapsed_ms = @intCast(std.time.milliTimestamp() - start_time),
        };
        printProgress(progress);
      }

      const iterNumber = iterationNumber(point, imax);
      const rgba = createRgba(iterNumber, imax);

      // Store colors
      @memcpy(colours[color_idx..color_idx + 4], &rgba);
      color_idx += 4;
  
      // Note: the @memcpy is equivalent to this....
      //colours[color_idx] = rgba[0];
      //colours[color_idx + 1] = rgba[1];
      //colours[color_idx + 2] = rgba[2];
      //colours[color_idx + 3] = rgba[3];
      //color_idx += 4;
    }

    // For debugging
    if (nb_points > 0) {
      const first_point = Point{
          .x = float_slice[0],
          .y = float_slice[1],
      };
      std.debug.print("First point: x={d}, y={d}\n", .{
          first_point.x,
          first_point.y,
      });
    }
  
    return beam.make(colours, .{ .as = .binary });
  }

  fn iterationNumber(p: Point, imax: usize) ?usize {
      if (p.x > 0.6 or p.x < -2.1) return null;
      if (p.y > 1.2 or p.y < -1.2) return null;
      // first cardiod
      if ((p.x + 1) * (p.x + 1) + p.y * p.y < 0.0625) return null;
  
      var x2: f64 = 0;
      var y2: f64 = 0;
      var w: f64 = 0;
  
      for (0..imax) |j| {
          if (x2 + y2 > 4) return j;
          const x: f64 = x2 - y2 + p.x;
          const y: f64 = w - x2 - y2 + p.y;
          x2 = x * x;
          y2 = y * y;
          w = (x + y) * (x + y);
      }
      return null;
  }

  fn createRgba(iter: ?usize, imax: usize) [4]u8 {
      // If it didn't escape, return black
      if (iter == null) return [_]u8{ 0, 0, 0, 255 };
  
      if (iter.? < imax and iter.? > 0) {
          const i = iter.? % 16;
          return switch (i) {
            0 => [_]u8{ 66, 30, 15, 255 },
            1 => [_]u8{ 25, 7, 26, 255 },
            2 => [_]u8{ 9, 1, 47, 255 },
            3 => [_]u8{ 4, 4, 73, 255 },
            4 => [_]u8{ 0, 7, 100, 255 },
            5 => [_]u8{ 12, 44, 138, 255 },
            6 => [_]u8{ 24, 82, 177, 255 },
            7 => [_]u8{ 57, 125, 209, 255 },
            8 => [_]u8{ 134, 181, 229, 255 },
            9 => [_]u8{ 211, 236, 248, 255 },
            10 => [_]u8{ 241, 233, 191, 255 },
            11 => [_]u8{ 248, 201, 95, 255 },
            12 => [_]u8{ 255, 170, 0, 255 },
            13 => [_]u8{ 204, 128, 0, 255 },
            14 => [_]u8{ 153, 87, 0, 255 },
            15 => [_]u8{ 106, 52, 3, 255 },
            else => [_]u8{ 0, 0, 0, 255 },
          };
      }
      return [_]u8{ 0, 0, 0, 255 };
  }

  fn printProgress(progress: Progress) void {
    const percentage = 
      @as(f32, @floatFromInt(progress.points_processed)) / 
                      @as(f32, @floatFromInt(progress.total_points)) * 100.0;
    
    const points_per_sec = 
      if (progress.elapsed_ms > 0)
        @as(f32, @floatFromInt(progress.points_processed)) / 
          (@as(f32, @floatFromInt(progress.elapsed_ms)) / 1000.0)
    else
        0.0;
    
    std.debug.print("\rProgress: {d:.1}% ({d} pts/sec)", .{
        percentage,
        @as(u32, @intFromFloat(points_per_sec)),
    });
  }
  """
end

defmodule KinoZig do
  use Kino.JS
  use Kino.JS.Live

  @h 1500
  @w 2000
  @imax 250
  #@rows_per_task 20

  def canvas(h, w) do
    """
    <canvas id="myCanvas" width=#{w} height=#{h}></canvas>
    """
  end

  def start(), do: Kino.JS.Live.new(__MODULE__, canvas(@h, @w))

  @impl true
  def init(html, ctx) do
    ctx = assign(ctx, %{max_iter: @imax, h: @h, w: @w})
    {:ok, assign(ctx, html: html)}
  end

  @impl true
  def handle_connect(ctx) do
    {:ok, ctx.assigns.html, ctx}
  end

  @impl true
  def handle_event("clicked", {:binary,%{"length" => length}, buffer}, %{assigns: assigns} = ctx) do
    %{h: _h, w: _w, max_iter: max_iter} = assigns
    IO.inspect({length, length == byte_size(buffer)}, label:  "length: ")
    colours = ZigSpeed.generate_view(buffer, length, max_iter)
      
    broadcast_event(ctx,"new", {:binary, %{}, colours})
    {:noreply, ctx}
  end

  
  asset "main.js" do
    """
    export function init(ctx, html) {
      ctx.root.innerHTML = html;

      const canvas = document.getElementById("myCanvas");
      const canvasCtx = canvas.getContext("2d");
      const canvasWidth = canvas.width, canvasHeight = canvas.height;
    
      // initial bounds
      let boundary = {min_x: -2, max_y: 1, max_x: 1, min_y: -1};

      // Function to convert canvas coordinate to complex coordinate
      function toCartesian(canvasX, canvasY, bounds) {
        const {min_x, max_x, min_y, max_y} = bounds;
        const x = min_x + (canvasX / (canvasWidth-1)) * (max_x - min_x);
        const y = max_y - (canvasY / (canvasHeight-1)) * (max_y - min_y);
        return { x, y };
      }

      function recalculateBounds(canvasX, canvasY, bounds, options = {}) {
        // Get the clicked point's corresponding 2D plane coordinates
        const { x: newCenterX, y: newCenterY } = toCartesian(canvasX, canvasY, bounds)
        const { zoomRatio = 5, zoomIn = true} = options;

        const {min_x, max_x, min_y, max_y} = bounds;
        // Compute the width and height of the new zoomed rectangle
        const oldWidth = max_x - min_x;
        const oldHeight = max_y - min_y;

        const factor = zoomIn ? 1/zoomRatio : zoomRatio;
        const newWidth = oldWidth * factor;
        const newHeight = oldHeight * factor;
      
        return { 
          min_x: newCenterX - newWidth / 2,
          max_x: newCenterX + newWidth / 2, 
          min_y: newCenterY - newHeight / 2, 
          max_y: newCenterY + newHeight / 2
        };
      }
    
      // received from server -----------------------------------
      ctx.handleEvent("new", ([_, binary]) => {
        console.log("new")
        const imageData = new ImageData(
          new Uint8ClampedArray(binary), 
          canvasWidth, 
          canvasHeight
        );
  
        // Render to canvas
        createImageBitmap(imageData).then(bitmap => canvasCtx.drawImage(bitmap, 0, 0));
      });
          

      // push from browser -------------------------------------
      canvas.addEventListener("click", (e) => {
        //if (!e.ctrlKey) return; // <-- click + ctrl pressed to zoom it
        const rect = canvas.getBoundingClientRect();
        const canvasX = e.clientX - rect.left;
        const canvasY = e.clientY - rect.top;
        const newBounds = recalculateBounds(canvasX, canvasY, boundary, {zoomIn: !e.shiftKey});
    
        //-- send data to the server -->
        Object.assign(boundary, newBounds);
        const buffer = getPoints(boundary)
        console.log(buffer.byteLength)
        ctx.pushEvent("clicked", [{length: buffer.byteLength}, buffer])
      });

      


      // compute all cartesians coordinntes in the current canvas
      function getPoints(bounds) {
        const buffer = new ArrayBuffer(canvasWidth * canvasHeight * 2 * 4); // 2 floats per pixel, 4 bytes each
        const floatArray = new Float32Array(buffer);

        let index = 0;
        for (let n = 0; n < canvasWidth * canvasHeight; n++) {
          const { x, y } = toCartesian(
              n % canvasWidth,              // i
              Math.floor(n / canvasWidth),  // j
              bounds
          );
          floatArray[n * 2] = x;
          floatArray[n * 2 + 1] = y;
        }
        return buffer;
      }

      // first render---------------
      const buffer = getPoints(boundary)
      ctx.pushEvent("clicked", [{length: buffer.byteLength}, buffer])
    }
    """
  end
end
```

```elixir
KinoZig.start()
```

<!-- livebook:{"offset":44300,"stamp":{"token":"XCP.abDJvGeTy0Spc72a9UjQnfAXg9-X-cJM20fYiamFy8FTNEjpWYobxIe3lw-X7Jz4YUoFTa667A4o6wDtrC4a5RoLXKayisyNBkU6K90NOUIxcJFz_r8uy34GJc9xxH0npHVaHktj4YAAWC6XXdOxFMPGgfxSPPC2_Dkc","version":2}} -->
