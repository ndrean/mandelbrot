// this code is autogenerated, do not check it into to your code repository

// ref livebook/mandelbrot.livemd#cell:kzovwjtpvmv4aa4r:7
const beam = @import("beam");
const std = @import("std");

const Point = struct { x: f32, y: f32 };
const point_size = @sizeOf(Point);
const Bounds = struct { topLeft: Point, bottomRight: Point, cols: usize, rows: usize };


/// nif: generate/5 Threaded
pub fn generate(
    rows: usize, 
    cols: usize, 
    imax: usize, 
    topLeft: [2]f32, 
    bottomRight: [2]f32
) !beam.term {
  const colours = try beam.allocator.alloc(u8, rows * cols * 4);
  defer beam.allocator.free(colours);

  const cpus = try std.Thread.getCpuCount();
  var threads = try beam.allocator.alloc(std.Thread, cpus);
  defer beam.allocator.free(threads);

  const base_rows_per_thread = rows / cpus;
  const remainder_rows = rows % cpus;

  const bounds = Bounds{
      .topLeft = Point{ .x = topLeft[0], .y = topLeft[1] },
      .bottomRight = Point{ .x = bottomRight[0], .y = bottomRight[1] },
      .cols = cols,
      .rows = rows,
  };

  for (0..cpus) |thread_id| {
    const start_row = thread_id * base_rows_per_thread;
    const extra_rows = if (thread_id == cpus - 1) remainder_rows else 0;
    const rows_per_thread = base_rows_per_thread + extra_rows;

    const args = .{colours, start_row, rows_per_thread, imax, bounds};
    threads[thread_id] = try std.Thread.spawn(.{}, processThread, args);
  }

  for (threads[0..cpus]) |thread| {
    thread.join();
  }

  return beam.make(colours, .{ .as = .binary });
}

// mutate the "colours" slice
fn processThread(
    colours: []u8, 
    start_row: usize, 
    rows_per_thread: usize,
    imax: usize, 
    bounds: Bounds
) void {
  var idx: usize = start_row;
  const end = start_row + rows_per_thread;

  while (idx < end) : (idx += 1) {
    for (0..bounds.cols) |j| {
      const point = mapPixel(.{ idx, j }, bounds);
      const iterNumber = iterationNumber(point, imax);
      const colour = createRgba(iterNumber, imax);
      const colour_idx = (idx * bounds.cols + j) * 4;
      @memcpy(colours[colour_idx..colour_idx + 4], &colour);
    }
  }
}

fn iterationNumber(p: Point, imax: usize) ?usize {
  if (p.x > 0.6 or p.x < -2.1) return null;
  if (p.y > 1.2 or p.y < -1.2) return null;
  // first cardiod
  if ((p.x + 1) * (p.x + 1) + p.y * p.y < 0.0625) return null;

  var x2: f64 = 0;
  var y2: f64 = 0;
  var w: f64 = 0;

  for (0..imax) |j| {
    if (x2 + y2 > 4) return j;
    const x: f64 = x2 - y2 + p.x;
    const y: f64 = w - x2 - y2 + p.y;
    x2 = x * x;
    y2 = y * y;
    w = (x + y) * (x + y);
  }
  return null;
}

fn createRgba(iter: ?usize, imax: usize) [4]u8 {
  // If it didn't escape, return black
  if (iter == null) return [_]u8{ 0, 0, 0, 255 };

  if (iter.? < imax and iter.? > 0) {
    const i = iter.? % 16;
    return switch (i) {
      0 => [_]u8{ 66, 30, 15, 255 },
      1 => [_]u8{ 25, 7, 26, 255 },
      2 => [_]u8{ 9, 1, 47, 255 },
      3 => [_]u8{ 4, 4, 73, 255 },
      4 => [_]u8{ 0, 7, 100, 255 },
      5 => [_]u8{ 12, 44, 138, 255 },
      6 => [_]u8{ 24, 82, 177, 255 },
      7 => [_]u8{ 57, 125, 209, 255 },
      8 => [_]u8{ 134, 181, 229, 255 },
      9 => [_]u8{ 211, 236, 248, 255 },
      10 => [_]u8{ 241, 233, 191, 255 },
      11 => [_]u8{ 248, 201, 95, 255 },
      12 => [_]u8{ 255, 170, 0, 255 },
      13 => [_]u8{ 204, 128, 0, 255 },
      14 => [_]u8{ 153, 87, 0, 255 },
      15 => [_]u8{ 106, 52, 3, 255 },
      else => [_]u8{ 0, 0, 0, 255 },
    };
  }
  return [_]u8{ 0, 0, 0, 255 };
}

// canvas-(i,j) are rows,cols and become (x,y) 2D-coordinates within the bounds
fn mapPixel(pixel: [2]usize, ctx: Bounds) Point {
  const x: f32 = ctx.topLeft.x + @as(f32, @floatFromInt(pixel[1])) / @as(f32,  @floatFromInt(ctx.cols)) * (ctx.bottomRight.x - ctx.topLeft.x);
  const y: f32 = ctx.topLeft.y - @as(f32, @floatFromInt(pixel[0])) / @as(f32,  @floatFromInt(ctx.rows)) * (ctx.topLeft.y - ctx.bottomRight.y);
  return Point{ .x = x, .y = y };
}
