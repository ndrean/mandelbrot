// this code is autogenerated, do not check it into to your code repository

// ref livebook/mandelbrot.livemd#cell:y5wusuardxn7x2xy:7
const beam = @import("beam");
const std = @import("std");
  
const print = std.debug.print;
  
const Point = struct { x: f32, y: f32 };
const point_size: usize = @sizeOf(Point);

const Progress = struct {
  points_processed: usize,
  total_points: usize,
  elapsed_ms: u64,
};

  
// / nif: generate_view
pub fn generate_view(data: [*]const u8, len: u32, imax: usize) !beam.term {
  if (len < @sizeOf(Point)) {
    return error.BufferTooSmall;
  }

  // Ensure the length is a multiple of point size
  if (len % @sizeOf(Point) != 0) {
      return error.InvalidBufferLength;
  }
  const start_time = std.time.milliTimestamp();

  // pointer the BEAM memory
  const raw_buffer = data[0..len];

  // Calculate how many points we expect
  const nb_points: usize = len / (@sizeOf(f32) * 2);

  // Create a slice of f32 values (two per point)
  const float_slice = std.mem.bytesAsSlice(f32, raw_buffer);

  const colours = try beam.allocator.alloc(u8, nb_points * 4);
  defer beam.allocator.free(colours);

  var i: usize = 0;
  var color_idx: usize = 0;
  while (i < float_slice.len) : (i += 2) {
    if (i + 1 >= float_slice.len) break;
    
    const point = Point{
        .x = float_slice[i],
        .y = float_slice[i + 1],
    };

    if (i % (float_slice.len / 10) == 0) {
      const progress = Progress{
          .points_processed = i / 2,
          .total_points = nb_points,
          .elapsed_ms = @intCast(std.time.milliTimestamp() - start_time),
      };
      printProgress(progress);
    }

    const iterNumber = iterationNumber(point, imax);
    const rgba = createRgba(iterNumber, imax);

    // Store colors
    @memcpy(colours[color_idx..color_idx + 4], &rgba);
    color_idx += 4;

    // Note: the @memcpy is equivalent to this....
    //colours[color_idx] = rgba[0];
    //colours[color_idx + 1] = rgba[1];
    //colours[color_idx + 2] = rgba[2];
    //colours[color_idx + 3] = rgba[3];
    //color_idx += 4;
  }

  // For debugging
  if (nb_points > 0) {
    const first_point = Point{
        .x = float_slice[0],
        .y = float_slice[1],
    };
    std.debug.print("First point: x={d}, y={d}\n", .{
        first_point.x,
        first_point.y,
    });
  }

  return beam.make(colours, .{ .as = .binary });
}

fn iterationNumber(p: Point, imax: usize) ?usize {
    if (p.x > 0.6 or p.x < -2.1) return null;
    if (p.y > 1.2 or p.y < -1.2) return null;
    // first cardiod
    if ((p.x + 1) * (p.x + 1) + p.y * p.y < 0.0625) return null;

    var x2: f64 = 0;
    var y2: f64 = 0;
    var w: f64 = 0;

    for (0..imax) |j| {
        if (x2 + y2 > 4) return j;
        const x: f64 = x2 - y2 + p.x;
        const y: f64 = w - x2 - y2 + p.y;
        x2 = x * x;
        y2 = y * y;
        w = (x + y) * (x + y);
    }
    return null;
}

fn createRgba(iter: ?usize, imax: usize) [4]u8 {
    // If it didn't escape, return black
    if (iter == null) return [_]u8{ 0, 0, 0, 255 };

    if (iter.? < imax and iter.? > 0) {
        const i = iter.? % 16;
        return switch (i) {
          0 => [_]u8{ 66, 30, 15, 255 },
          1 => [_]u8{ 25, 7, 26, 255 },
          2 => [_]u8{ 9, 1, 47, 255 },
          3 => [_]u8{ 4, 4, 73, 255 },
          4 => [_]u8{ 0, 7, 100, 255 },
          5 => [_]u8{ 12, 44, 138, 255 },
          6 => [_]u8{ 24, 82, 177, 255 },
          7 => [_]u8{ 57, 125, 209, 255 },
          8 => [_]u8{ 134, 181, 229, 255 },
          9 => [_]u8{ 211, 236, 248, 255 },
          10 => [_]u8{ 241, 233, 191, 255 },
          11 => [_]u8{ 248, 201, 95, 255 },
          12 => [_]u8{ 255, 170, 0, 255 },
          13 => [_]u8{ 204, 128, 0, 255 },
          14 => [_]u8{ 153, 87, 0, 255 },
          15 => [_]u8{ 106, 52, 3, 255 },
          else => [_]u8{ 0, 0, 0, 255 },
        };
    }
    return [_]u8{ 0, 0, 0, 255 };
}

fn printProgress(progress: Progress) void {
  const percentage = 
    @as(f32, @floatFromInt(progress.points_processed)) / 
                    @as(f32, @floatFromInt(progress.total_points)) * 100.0;
  
  const points_per_sec = 
    if (progress.elapsed_ms > 0)
      @as(f32, @floatFromInt(progress.points_processed)) / 
        (@as(f32, @floatFromInt(progress.elapsed_ms)) / 1000.0)
  else
      0.0;
  
  std.debug.print("\rProgress: {d:.1}% ({d} pts/sec)", .{
      percentage,
      @as(u32, @intFromFloat(points_per_sec)),
  });
}
