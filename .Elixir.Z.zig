// this code is autogenerated, do not check it into to your code repository

// ref test.exs:6
const beam = @import("beam");
const std = @import("std");
const Cx = std.math.Complex(f64);

const IMAX = 400;
const Res_x = 1_000;
const Res_y = 1_000;
const topLeft = Cx{ .re = -2.0, .im = 1.2 };
const bottomRight = Cx{ .re = 0.6, .im = -1.2 };
const w = bottomRight.re - topLeft.re;
const h = topLeft.im - bottomRight.im;



pub fn generate_mandelbrot() !beam.term {
  const pixels = try beam.allocator.alloc(u8, Res_x * Res_y * 3);
  defer beam.allocator.free(pixels);
  const res = try createUnthreadedSlice(pixels);
  return beam.make(res, .{});
}

fn createUnthreadedSlice(pixels: []u8) !beam.term {
  const rows_to_process = Res_x / 2 + Res_x % 2;
  for (0..rows_to_process) |current_row| {
      for (0..Res_y) |current_col| {
          const c = pixelToComplex(.{ @as(u32, @intCast(current_col)), @as(u32, @intCast(current_row)) });
          const iter = getIter(c);
          const colour = createRgb(iter);
          const pixel_index = (current_row * Res_y + current_col) * 3;
          // copy RGB values to consecutive memory locations
          pixels[pixel_index + 0] = colour[0]; //R
          pixels[pixel_index + 1] = colour[1]; //G
          pixels[pixel_index + 2] = colour[2]; //B

          const mirror_y = Res_x - 1 - current_row;
          if (mirror_y != current_row) {
              const mirror_pixel_index = (mirror_y * Res_y + current_col) * 3;
              pixels[mirror_pixel_index + 0] = colour[0]; //R
              pixels[mirror_pixel_index + 1] = colour[1]; //G
              pixels[mirror_pixel_index + 2] = colour[2]; //B
          }
      }
  }
  return beam.make(pixels, .{});
}

fn pixelToComplex(pix: [2]u32) Cx {
  const re = @as(f64, @floatFromInt(pix[0])) / @as(f64, @floatFromInt(Res_x)) * w;
  const im = @as(f64, @floatFromInt(pix[1])) / @as(f64, @floatFromInt(Res_y)) * h;
  return Cx{ .re = (topLeft.re + re) * w, .im = (topLeft.im - im) * h };
}

fn getIter(c: Cx) ?usize {
  if (c.re > 0.6 or c.re < -2.1) return null;
  if (c.im > 1.2 or c.im < -1.2) return null;

  var z = Cx{ .re = 0.0, .im = 0.0 };

  for (0..IMAX) |j| {
      if (sqnorm(z) > 4) return j;
      z = Cx.mul(z, z).add(c);
  }
  return null;
}

fn sqnorm(z: Cx) f64 {
  return z.re * z.re + z.im * z.im;
}

fn createRgb(iter: ?usize) [3]u8 {
  // If it didn't escape, return black
  if (iter == null) return [_]u8{ 0, 0, 0 };

  // Normalize time to [0,1] now that we know it escaped
  const normalized = @as(f64, @floatFromInt(iter.?)) / @as(f64, @floatFromInt(IMAX));

  if (normalized < 0.5) {
      const scaled = normalized * 2;
      return [_]u8{ @as(u8, @intFromFloat(255.0 * (1.0 - scaled))), @as(u8, @intFromFloat(255.0 * (1.0 - scaled / 2))), @as(u8, @intFromFloat(127 + 128 * scaled)) };
  } else {
      const scaled = (normalized - 0.5) * 2.0;
      return [_]u8{ 0, @as(u8, @intFromFloat(127 * (1 - scaled))), @as(u8, @intFromFloat(255.0 * (1.0 - scaled))) };
  }
}


